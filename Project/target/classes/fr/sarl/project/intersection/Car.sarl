/** 
 * 
 */
package fr.sarl.project.intersection

import io.sarl.core.ContextJoined
import io.sarl.core.ContextLeft
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Logging
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Schedules
import io.sarl.core.Lifecycle
import java.util.UUID
import org.arakhne.afc.math.geometry.d2.d.Vector2d
import java.util.Collection
import org.arakhne.afc.math.geometry.d2.d.Shape2d
import org.arakhne.afc.math.geometry.d2.d.Path2d
import org.arakhne.afc.math.geometry.d2.d.PathElement2d.QuadPathElement2d
import org.arakhne.afc.math.geometry.d2.d.PathElement2d
import org.arakhne.afc.math.geometry.PathElementType
import java.util.Iterator
import java.util.ArrayList

/** 
 * @author ASaunier
 * 
 */
agent Car 
{
	uses Logging, DefaultContextInteractions, Schedules, Lifecycle
	
	// ID of the environmental agent
	var environment : UUID
	
	// variable of the car
	var position : Vector2d
	var speed : Vector2d
	var acceleration : Double
	var destination : Vector2d
	var direction : int
	/* direction value :
	 * [0] North
	 * [1] West
	 * [2] East
	 * [3] South
	 * */
	 
	var group :Population
		

	on Initialize {
		// Event trigger before the agent begin to live or to be used.
		// You should put all the initialization statements in this block of code.
		
		//TODO Code to Initialize the car
		
		info("The agent was started.")
		if (occurrence.parameters.size > 1) {
			if (occurrence.parameters.get(0) instanceof UUID) {
				environment = occurrence.parameters.get(0) as UUID
			}
			if (occurrence.parameters.get(1) instanceof Population) {
				group = occurrence.parameters.get(1) as Population
				this.acceleration = group.maxAcc
			}
			if (occurrence.parameters.get(2) instanceof Vector2d) {
				this.position = occurrence.parameters.get(2) as Vector2d
				if (this.position.y>800){
					direction=0
				} else if (this.position.y < 200) {
					direction = 3
				} else if (this.position.x >800) {
					direction = 1
				} else if (this.position.x < 200) {
					direction = 2
				}
			}
			if (occurrence.parameters.get(3) instanceof Vector2d) {
				this.destination = occurrence.parameters.get(3) as Vector2d
			}
		}
		this.speed.length=0.0
		
	}

	on Destroy {
		// Event triggered when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent was stopped.")
		killMe
	}


	on ContextJoined {
		// Event triggered when an agent of the level joins a shared context.
		// Sent to a agent of the same level.
		
		//TODO Code to present the car to the intersection when it joined it
		info("a car joined the intersection")
		
	}

	on ContextLeft {
		// Event trigger when an agent of the level jleaves a shared context.
		// Sent to a agent of the same level.
		
		//TODO Code for when the car leave the intersection
		
	}
	
	on Wait {
		
		//TODO Code for when the car need to wait
		speed.set(0.0,0.0)
		//TODO define a deceleration
		
	}	
	
	on Go {
		
		//TODO Code for when the car can go
		
	}
	on Perception{
		// TODO 
		var cars = occurrence.perceivedAgentBody
		var myBody = cars.get(ID)
		if ((myBody !== null) && (myBody.owner == this.ID)) {
			// Update car speed and position according to the new environmental data
			this.position = myBody.position
			this.speed = myBody.speed
			this.direction=myBody.direction
		}
		in(Settings::pause) [
			

			if (Settings::isLogActivated) {
				info("Sending Influences.")
			}
		]
		
		}
	
	on Die
	{
		info("Agent car stopped by the environment")
		killMe
	}

	def follow(carToFollow : CarBody) : Vector2d {

		if ((carToFollow !== null) && (carToFollow.owner != this.ID)) {
			
			//TODO Code for the car to follow another one
			
		}

	}
	def acceleration  {
		//acceleration linéaire en fonction de la direction du véhicule 
		
			if (direction == 1 && this.speed.x <= group.maxSpeed) {
				this.speed.setX(this.speed.getX + acceleration)
				this.speed.setY(0)
			}
			else if (direction == 2 && this.speed.y >= -group.maxSpeed) {
				this.speed.setY(this.speed.getY - acceleration)
				this.speed.setX(0)
			} 
			else if (direction == 3 && this.speed.y <= group.maxSpeed) {
				this.speed.setY(this.speed.getY + acceleration)
				this.speed.setX(0)
			} 
			else if (direction == 4 && this.speed.x >= -group.maxSpeed) {
				this.speed.setX(this.speed.getX - acceleration)
				this.speed.setY(0)
			}
			else{
				info("error direction acceleration ")
			}
		
	}

	def decceleration {
		// decceleration linéaire en fonction de la direction du véhicule
		if (this.speed.length < 0.0) {
			if (direction == 1 && this.speed.x >= 0.0) {
				this.speed.setX(this.speed.getX - acceleration)
			} else if (direction == 2 && this.speed.y<=0.0) {
				this.speed.setY(this.speed.getY +acceleration)
			} else if (direction == 3 && this.speed.y>=0.0) {
				this.speed.setY(this.speed.getY - acceleration)
			} else if (direction == 4 && this.speed.y<=0.0) {
				this.speed.setX(this.speed.getX + acceleration)
			} else {
				info("error direction decceleration")
			}
		}
	}
	/*
	 * dir 
	 * [1] right
	 * [2] left
	 * [3] straight
	 * return list of position for curved deplacement in intersection
	 */
	def traverserInter(dir : int) {
		var point = new Vector2d
		var cible= new Vector2d
		var courbe = new Path2d
		courbe.setLastPoint(this.position.getX(), this.position.getY())
		if (dir == 1){
			if (this.direction == 0) {
				point.setX(this.position.getX())
				point.setY(this.position.getY() + 50)
				cible.setX(this.position.getX()+50)
				cible.setY(this.position.getY() + 50)
				//var q = new QuadPathElement2d(this.position.getX, this.position.getY, point.getX(),
				//	point.getY(), cible.getX(), cible.getY())
				//var a =new ArrayList()
				//a.add(q)
				//var i =a.iterator()
				//courbe = new Path2d(i)
				courbe.quadTo(point.getX(),
						point.getY(), cible.getX(), cible.getY())
				
			}
			if (this.direction == 1) {
				point.setX(this.position.getX()+50)
				point.setY(this.position.getY() )
				cible.setX(this.position.getX()+50)
				cible.setY(this.position.getY() - 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())
				
				}
			if (this.direction == 2) {
				point.setX(this.position.getX()-50)
				point.setY(this.position.getY() )
				cible.setX(this.position.getX()-50)
				cible.setY(this.position.getY() + 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())
				}
			if (this.direction == 3) {
				point.setX(this.position.getX())
				point.setY(this.position.getY() - 50)
				cible.setX(this.position.getX()-50)
				cible.setY(this.position.getY() - 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())
				}
			
		} else if (dir == 2) {
			if (this.direction == 0) {
				point.setX(this.position.getX())
				point.setY(this.position.getY() + 50)
				cible.setX(this.position.getX() - 50)
				cible.setY(this.position.getY() + 50)
				// var q = new QuadPathElement2d(this.position.getX, this.position.getY, point.getX(),
				//	point.getY(), cible.getX(), cible.getY())
				// var a =new ArrayList()
				// a.add(q)
				// var i =a.iterator()
				// courbe = new Path2d(i)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())

			}
			if (this.direction == 1) {
				point.setX(this.position.getX() + 50)
				point.setY(this.position.getY())
				cible.setX(this.position.getX() + 50)
				cible.setY(this.position.getY() + 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())

			}
			if (this.direction == 2) {
				point.setX(this.position.getX() - 50)
				point.setY(this.position.getY())
				cible.setX(this.position.getX() + 50)
				cible.setY(this.position.getY() - 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())
			}
			if (this.direction == 3) {
				point.setX(this.position.getX())
				point.setY(this.position.getY() - 50)
				cible.setX(this.position.getX() - 50)
				cible.setY(this.position.getY() - 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())
				}
			
		} else if(dir == 3){
			
			
		}
		
		return courbe.toPointArray()
		
	}
	
	

	def think(perception : Collection<CarBody>) : Vector2d {
		if (perception !== null) {}
		
		}

}
