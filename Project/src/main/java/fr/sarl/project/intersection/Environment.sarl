package fr.sarl.project.intersection

import fr.sarl.project.intersection.gui.EnvironmentGui
import io.sarl.bootstrap.SREBootstrap
import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.OpenEventSpace
import io.sarl.core.Schedules
import java.util.ArrayList
import java.util.UUID
import java.util.concurrent.ConcurrentSkipListSet
import org.arakhne.afc.math.geometry.d2.d.Vector2d
import org.eclipse.xtend.lib.annotations.Accessors
import java.util.concurrent.ConcurrentHashMap

/** 
 * The environmental agent in charge of collecting cars influences and computing the new state of the virtual world
 * @author Nicolas Gaud
 */
agent Environment {

	uses Logging, DefaultContextInteractions, Schedules, Lifecycle

	var kernel : SREBootstrap

	@Accessors
	var width : int

	@Accessors
	var height : int

	@Accessors
	var listIntersectionBody : ArrayList<IntersectionBody>
	
	@Accessors
	//var listCarBody : ArrayList<CarBody> = newArrayList
	var carBodies : ConcurrentHashMap<UUID, CarBody>
	
	@Accessors
	var population : Population = new Population()

	/** 
	 * The Graphical user interface
	 */
	var myGUI : EnvironmentGui

	/*
	@Accessors
	var cars : ConcurrentHashMap<UUID, CarBody> */

	// Set of cars ID who has sent their influence in the current time step
	@Accessors
	var influences : ConcurrentSkipListSet<UUID>

	def addRandomNumberOfCar(min : int, max : int):void
	{
		var alea = (min + (Math.random() * ((max - min) + 1))).toInteger
		
		for (var i = 0; i < alea; i++)
		{
			var randomRoadSectionSpawn = randomRoadSection(listIntersectionBody.get(0))
			var randomRoadSectionDestination = randomRoadSection(listIntersectionBody.get(0))
			var carId = UUID.randomUUID 
			var car = new CarBody(carId,
				randomRoadSectionSpawn.spawnPoint,
				randomRoadSectionSpawn.numSection,
				new Vector2d(0,0),
				0
			)
			carBodies.put(carId,car)
			//listCarBody.add(car)
			randomRoadSectionSpawn.waitingList.add(car)
			kernel.startAgentWithID(typeof(Car), carId, 
				listIntersectionBody.get(0).owner,
				population,
				randomRoadSectionSpawn.spawnPoint,
				randomRoadSectionSpawn.numSection,
				randomRoadSectionDestination.exitPoint,
				randomRoadSectionDestination.numSection
				)
		}
			
	}
	
	def randomRoadSection(intersectionBody : IntersectionBody) : RoadSection {
		val rand = (Math.random() * intersectionBody.roadSections.length).toInteger
		return intersectionBody.roadSections.get(rand)
	}
	
	/*def addCarInRoadSection(c : Car,roadSection : RoadSection)
	{
		var sPoint = roadSection.spawnPoint
		if(sPoint !== null)
		{
			// 	new(owner : UUID, position : Vector2d, roadSection : int, speed : Vector2d)
			var car : CarBody = new CarBody(c.ID, sPoint, roadSection.numSection,new Vector2d(2,2))	
		}
	}*/

	on Initialize 
	{
		loggingName = "Environment"
		// Environment init parameters : An Integer the grid's height, An integer the grid's width
		if (occurrence.parameters.size > 1) {
			if (occurrence.parameters.get(0) instanceof Integer) {
				height = occurrence.parameters.get(0) as Integer
			}

			if (occurrence.parameters.get(1) instanceof Integer) {
				width = occurrence.parameters.get(1) as Integer
			}
			if (occurrence.parameters.get(2) instanceof SREBootstrap)
			{
				kernel = occurrence.parameters.get(2) as SREBootstrap
			}
			
			
			/*
			 * car body = new body
			 * simu.add(body)
			 * 
			 * kernel.spawnWithID(typeof(..),ID)
			 */
			carBodies = new ConcurrentHashMap
			listIntersectionBody = newArrayList
			var intersectionId = UUID.randomUUID()
			var intersectionBody = new IntersectionBody(intersectionId)  // links the body to its owner agent (what we actually have in the environment agent)
			kernel.startAgentWithID(typeof(Intersection), intersectionId, intersectionBody) // starts our intersection agent
			
			population.maxAcc = 5.0
			population.maxSpeed = 5.0
			
			/*var myCar =kernel.startAgent(typeof(Car))
			// new(owner : UUID, position : Vector2d, roadSection : int, speed : Vector2d)
			var aRoadSection = intersectionBody.roadSections.get(0)
			var myCarBody = new CarBody(myCar, aRoadSection.spawnPoint, aRoadSection.numSection,
				new Vector2d(0,2))
				
			aRoadSection.waitingList.add(myCarBody)*/
			listIntersectionBody.add(intersectionBody)
			
			addRandomNumberOfCar(5,15)
			
			this.myGUI = new EnvironmentGui(defaultSpace as OpenEventSpace, height, width, this.listIntersectionBody)
			
			//cars = null
			
			influences = new ConcurrentSkipListSet
			
			
			myGUI.repaint
			
		}
	}

	on Start 
	{
		//this.cars = occurrence.perceivedAgentBody
		//new GuiRepaint(cars).emit
		//new Perception(boids).emit
	}

	on Action 
	{
		// TODO
		synchronized (carBodies) {
			synchronized (influences) { // Two very important "synchronized" blocks that prevent the simulation from thread interblocking
				if (carBodies.containsKey(occurrence.source.UUID)) {
					this.influences.add(occurrence.source.UUID)
					
					//TODO
					//applyForce(occurrence.influence, carBodies.get(occurrence.source.UUID))
				}

				if (this.influences.size == this.carBodies.size) {
					// All boids have sent their influences
					in(Settings::pause) [
						this.myGUI.repaint
						new Perception(carBodies).emit
						if (Settings::isLogActivated) {
							info("New Simulation Step.")
						}
					]
					this.influences.clear
				}
			}
		}
	}

	on Die 
	{
		killMe
	}

	on GuiRepaint
	{
		this.myGUI.repaint()
	}
	
	on UpdateTimer {
		myGUI.setTimer(occurrence.timer)
	}

}
