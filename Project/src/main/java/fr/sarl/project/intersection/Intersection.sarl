/** 
 * 
 */
package fr.sarl.project.intersection

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.util.ArrayList
import java.util.Date
import java.util.LinkedList
import java.util.Map
import java.util.PriorityQueue
import java.util.Queue
import java.util.TreeMap
import java.util.UUID
import org.arakhne.afc.math.geometry.d2.d.Vector2d
import org.eclipse.xtend.lib.annotations.Accessors

/** 
 * @author louec
 * 
 */
agent Intersection {
	uses Logging, Lifecycle, Schedules, DefaultContextInteractions
	
	/** Cars currently in the context of the intersection */
	val cars : Map<UUID, PerceivedCar> = new TreeMap
	
	/** The road sections in our intersection */
	@Accessors
	val containerRoadSections : ArrayList<RoadSection> = newArrayList
	
	/** Waiting queues for each road section of the intersection */
	val roadSections : Map<Integer, Queue<UUID>> = new TreeMap
	val roadSectionIds : int[] = #[-1, -1, -1, -1]

	val crossingSquareReservations : UUID[] = #[null, null, null, null]
	val SQUARE_NE = 0
	val SQUARE_NW = 1
	val SQUARE_SW = 2
	val SQUARE_SE = 3

	/**
	 * Init parameters :
	 * [0-3] Road section numbers (/!\ before changing sending order, update "position" in enum CrossroadDirection /!\)
	 * [0] Northern
	 * [1] Western
	 * [2] Eastern
	 * [3] Southern
	 */
	on Initialize {		
		// init waiting queues
		for (var i = 0; i < 4; i++) {
			var id = occurrence.parameters.get(i) as Integer
			roadSections.put(id, new LinkedList)
			roadSectionIds.set(i, id)
		}
		
		info("Intersection created")
		
		every(500) [
			manageCrossroad
		]
	}
	
	/**
	 * Overall management of the crossroad
	 */
	def manageCrossroad () {
		val waitingCars : PriorityQueue<PerceivedCar> = waitingCarsByEnteringOrder
		
		while (waitingCars.peek !== null) {
			var car = waitingCars.poll
			
			synchronized (crossingSquareReservations) { 
				if (isPathFree(car.enteringRoadSection, car.targetRoadSection)) {
					allowToGo(car)
				}
			}
		}
	}
	
	/**
	 * Get the first waiting cars on each road section and order them by entering time
	 */
	def waitingCarsByEnteringOrder() : PriorityQueue<PerceivedCar> {
		val waitingCars : PriorityQueue<PerceivedCar> = new PriorityQueue()
		
		// save the first car of each road section if there is one
		for (rsId : roadSectionIds) {
			var roadSection = roadSections.get(rsId)
			
			synchronized(roadSection) {
				var carId = roadSection.peek
				if (carId !== null) {
					waitingCars.add(cars.get(carId))
				}
			}
		}
		
		return waitingCars
	}
	
	/**
	 * Convert a road section id to a CrossroadDirection
	 */
	def rsIdToDirection(roadSectionId : int) {
		var i : int
		for (i = 0; i < roadSectionIds.length && roadSectionIds.get(i) != roadSectionId; i++) {}		
		return CrossroadDirection.fromPosition(i)
	}

	/**
	 * Check if the path from one direction to another is not yet reserved
	 * @return true if the path is free, false else
	 */
	def isPathFree(fromId : int, toId : int) : boolean {
		var from : CrossroadDirection = rsIdToDirection(fromId)
		var to : CrossroadDirection = rsIdToDirection(toId)
		
		val path = from.findPath(to, SQUARE_NW, SQUARE_NE, SQUARE_SE, SQUARE_SW)
		var isFree = true

		for (square : path) {
			isFree = isFree && crossingSquareReservations.get(square) === null
		}

		return isFree
	}
	
	/**
	 * Allow a car to cross the intersection
	 * Lock its path and remove it from the currently waiting cars
	 */
	def allowToGo(car: PerceivedCar) {
		lockPath(car.enteringRoadSection, car.targetRoadSection, car.id)
		car.isGoing = true

		// remove the car from its road section
		val roadSectionNumber = cars.get(car.id).enteringRoadSection
		val roadSection = roadSections.get(roadSectionNumber)
		synchronized (roadSection) {
			roadSection.remove(car.id)
		}
		
		new Go().emit[it.UUID == car.id]
	}

	/** 
	 * Reserve the path from one direction to another for a given car
	 */
	def lockPath(fromId : int, toId : int, reserver : UUID) {
		var from : CrossroadDirection = rsIdToDirection(fromId)
		var to : CrossroadDirection = rsIdToDirection(toId)
		
		val path = from.findPath(to, SQUARE_NW, SQUARE_NE, SQUARE_SE, SQUARE_SW)

		for (square : path) {
			crossingSquareReservations.set(square, reserver)
		}
	}

	/**
	 * Unlock a crossing square
	 */
	def unlockSquare(square : int) {
		synchronized (crossingSquareReservations) {
			crossingSquareReservations.set(square, null)
		}
	}

	/** 
	 * Triggered when a car joins the context of the intersection
	 * Add the new car to the lists of known entities
	 */
	on JoinIntersection {
		// save only the needed info
		val car = new PerceivedCar(occurrence.carId, occurrence.position, occurrence.roadSection, occurrence.target)

		// store it
		synchronized (cars) {
			cars.put(car.id, car)
		}

		// assign it to the right road section
		val roadSection = roadSections.get(car.enteringRoadSection)
		synchronized (roadSection) {
			roadSection.add(car.id)
		}
	}

	/** 
	 * Triggered when a car leaves the context of the intersection
	 * Remove the new car from the lists of known entities
	 */
	on LeaveIntersection {
		// remove the car from the storage
		synchronized (cars) {
			cars.remove(occurrence.carId)
		}
	}

	on Die {
		killMe
	}

	on Destroy {
		info("Intersection destroyed")
	}

	/** 
	 * Minimalization of a CarBody with only the required information for the Intersection
	 */
	static class PerceivedCar implements Comparable<PerceivedCar>  {

		@Accessors
		val id : UUID

		@Accessors
		var position : Vector2d

		// Id of the current road section
		@Accessors
		val enteringRoadSection : int

		// Id of the targeted road section
		@Accessors
		val targetRoadSection : int
		
		@Accessors
		val enteringTime : long
		
		@Accessors
		var isGoing : boolean

		new(id : UUID, position : Vector2d, roadSection : int, target : int) {
			this.id = id
			this.position = position
			this.enteringRoadSection = roadSection
			this.targetRoadSection = target
			this.enteringTime = new Date().getTime()
			this.isGoing = false
		}
	
		def compareTo(otherCar : PerceivedCar) : int {
			return enteringTime.compareTo(otherCar.enteringTime)
		}
	}
}
