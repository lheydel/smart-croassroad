/** 
 * 
 */
package fr.sarl.project.intersection

import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import java.util.ArrayList
import java.util.HashMap
import java.util.LinkedList
import java.util.Map
import java.util.Queue
import java.util.UUID
import org.arakhne.afc.math.geometry.d2.d.Vector2d
import org.eclipse.xtend.lib.annotations.Accessors

/** 
 * @author louec
 * 
 */
agent Intersection {
	uses Logging, Lifecycle
	
	/** Cars currently in the context of the intersection */
	val cars : Map<UUID, PerceivedCar> = new HashMap
	
	/** The road sections in our intersection */
	@Accessors
	val containerRoadSections : ArrayList<RoadSection> = newArrayList
	
	/** Waiting queues for each road section of the intersection */
	val roadSections : Map<Integer, Queue<UUID>> = new HashMap
	val roadSectionIds : int[] = #[-1, -1, -1, -1]

	val crossingSquareReservations : UUID[] = #[null, null, null, null]
	val SQUARE_NE = 0
	val SQUARE_NW = 1
	val SQUARE_SW = 2
	val SQUARE_SE = 3

	/**
	 * Init parameters :
	 * [0-3] Road section numbers (/!\ before changing sending order, update "position" in enum CrossroadDirection /!\)
	 * [0] Northern
	 * [1] Western
	 * [2] Eastern
	 * [3] Southern
	 */
	on Initialize {		
		// init waiting queues
		for (var i = 0; i < 4; i++) {
			var id = occurrence.parameters.get(i) as Integer
			roadSections.put(id, new LinkedList)
			roadSectionIds.set(i, id)
		}
		
		info("Intersection created")
	}

	/** 
	 * Triggered when a car joins the context of the intersection
	 * Add the new car to the lists of known entities
	 */
	on JoinIntersection {
		// save only the needed info
		val car = new PerceivedCar(occurrence.carId, occurrence.position, occurrence.roadSection, occurrence.target)
		
		// store it
		synchronized(cars) {
			cars.put(car.id, car)
		}
		
		// assign it to the right road section
		val roadSection = roadSections.get(car.enteringRoadSection)
		synchronized(roadSection) {
			roadSection.add(car.id)
		}
	}

	/** 
	 * Triggered when a car leaves the context of the intersection
	 * Remove the new car from the lists of known entities
	 */
	on LeaveIntersection { 
		// remove the car from its road section
		val roadSectionNumber = cars.get(occurrence.carId).enteringRoadSection
		val roadSection = roadSections.get(roadSectionNumber) 
		synchronized (roadSection) {
			roadSection.remove(occurrence.carId)
		}
		
		// remove the car from the storage
		synchronized (cars) {
			cars.remove(occurrence.carId)
		}
	}
	
	on Destroy {
		info("Intersection destroyed")
	}

	/**
	 * Check if the path from one direction to another is not yet reserved
	 * @return true if the path is free, false else
	 */
	def isPathFree(from : CrossroadDirection, to : CrossroadDirection) : boolean {
		val path = from.findPath(to, SQUARE_NW, SQUARE_NE, SQUARE_SE, SQUARE_SW)
		var isFree = true

		synchronized (crossingSquareReservations) {
			for (square : path) {
				isFree = isFree && crossingSquareReservations.get(square) === null
			}
		}

		return isFree
	}

	/** 
	 * Reserve the path from one direction to another for a given car
	 */
	def lockPath(from : CrossroadDirection, to : CrossroadDirection, reserver : UUID) {
		val path = from.findPath(to, SQUARE_NW, SQUARE_NE, SQUARE_SE, SQUARE_SW)

		synchronized (crossingSquareReservations) {
			for (square : path) {
				crossingSquareReservations.set(square, reserver)
			}
		}
	}

	def unlockSquare(square : int) {
		synchronized (crossingSquareReservations) {
			crossingSquareReservations.set(square, null)
		}
	}
	on Die 	{
		killMe
	}

	/** 
	 * Minimalization of a CarBody with only the required information for the Intersection
	 */
	static class PerceivedCar  {

		@Accessors
		val id : UUID

		@Accessors
		var position : Vector2d

		// Id of the current road section
		@Accessors
		val enteringRoadSection : int

		// Id of the targetted road section
		@Accessors
		val targetRoadSection : int

		new(id : UUID, position : Vector2d, roadSection : int, target : int) {
			this.id = id
			this.position = position
			this.enteringRoadSection = roadSection
			this.targetRoadSection = target
		}
	}
}
