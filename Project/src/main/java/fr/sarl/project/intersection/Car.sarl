/** 
 * 
 */
package fr.sarl.project.intersection

import io.sarl.core.DefaultContextInteractions
import io.sarl.core.Destroy
import io.sarl.core.Initialize
import io.sarl.core.Lifecycle
import io.sarl.core.Logging
import io.sarl.core.Schedules
import java.util.Collection
import java.util.UUID
import org.arakhne.afc.math.geometry.d2.d.Path2d
import org.arakhne.afc.math.geometry.d2.d.Vector2d
import org.arakhne.afc.math.geometry.d2.d.Point2d

/** 
 * @author ASaunier
 * 
 */
agent Car 
{
	uses Logging, DefaultContextInteractions, Schedules, Lifecycle
	
	
	var environment : UUID
	// ID of the environmental agent
	var intersection : UUID
	
	// variable of the car
	var position : Vector2d
	var roadSectionSpawn : int
	var speed : Vector2d
	var acceleration : Double
	var destination : int
	var roadSectionDestination : int
	var vectorEndPoint : Vector2d
	/* direction value :
	 * [0] South
	 * [1] West
	 * [2] East
	 * [3] North
	 */
	var direction : int
	var group :Population
	var canGo = false
	var nextTo = false
	var cheminIntersection : Point2d[]
	var progressionIntersection = 0
		

	on Initialize {
		// Event trigger before the agent begin to live or to be used.
		// You should put all the initialization statements in this block of code.
		
		// TODO Code to Initialize the car
		environment = occurrence.parameters.get(0) as UUID
		intersection = occurrence.parameters.get(1) as UUID
		group = occurrence.parameters.get(2) as Population
		acceleration = group.maxAcc
		position = occurrence.parameters.get(3) as Vector2d
		if (position.y > 600) {
			direction = 3
		} else if (position.y < 400) {
			direction = 0
		} else if (position.x > 600) {
			direction = 1
		} else if (position.x < 400) {
			direction = 2
		}
		roadSectionSpawn = occurrence.parameters.get(4) as Integer
		vectorEndPoint = occurrence.parameters.get(5) as Vector2d
		roadSectionDestination = occurrence.parameters.get(6) as Integer
		speed = new Vector2d(0, 0)
		
		
		switch(roadSectionSpawn){
			case 0:{
				if(roadSectionDestination == 0) destination = 0 
				else if(roadSectionDestination == 2) destination = 1
				else if(roadSectionDestination == 1) destination = 2
				else if(roadSectionDestination == 3) destination = 3
			}
			case 1: {
				if (roadSectionDestination == 0) destination = 1
				else if (roadSectionDestination == 2)destination = 3
				else if(roadSectionDestination == 1) destination = 0 
				else if(roadSectionDestination == 3) destination = 2
			}
			case 2: {
				if (roadSectionDestination == 0 )destination = 2
				else if (roadSectionDestination == 2) destination = 0
				else if(roadSectionDestination == 1) destination = 3
				else if(roadSectionDestination ==3) destination = 1
			}
			case 3: {
				if (roadSectionDestination == 0) destination = 3
				else if (roadSectionDestination == 2) destination = 2
				else if(roadSectionDestination == 1) destination = 1
				else if(roadSectionDestination ==3) destination = 0
			}
		}
		
		
		info("Car : " + this.ID + " was started.")
		info("at init " + this.position + " || " + speed + " || " + direction)
		val waitTask = task("waiting_to_die")
		waitTask.every(100) [
			waitTask.cancel
		]
		
		new CarReady().emit[it.UUID == environment]
		
		emit(new JoinIntersection(
			this.ID,
			position,
			roadSectionSpawn,
			roadSectionDestination			
		))[it.UUID == intersection]
	}

	on Destroy {
		// Event triggered when the agent is destroyed from the system.
		// You should put all the resource releasing statements in this block of code.
		info("The agent : " + this.ID + " was stopped.")
		killMe
	}
	
	
	on Wait {
		
		//TODO Code for when the car need to wait
		speed.set(0.0,0.0)
		//TODO define a deceleration
		
	}	
	
	on Go {
		
		// TODO Code for when the car can go
		if (occurrence.carToFollow == null) {
			canGo = true
		}else{
			
		}
		
		
		// Update postion
		new UpdatePosition(this.ID,this.position).emit[it.UUID == this.intersection]
		
	}
	on Perception{
		// TODO 
		var frontCar = occurrence.frontCarBody
		var myBody = occurrence.carBody
		if ((myBody !== null) && (myBody.owner == this.ID)) {
			// Update position of body 
			this.position = myBody.position
		}
		
		in(Settings::pause) [
			emit(new Action(think(frontCar), this.direction))[it.UUID == this.environment]
			

			if (Settings::isLogActivated) {
				info("Sending Influences.")
			}
		]
		
		//TODO Check if there is a car in front
		
		
		//if there is, manage decceleration to stop before iter
		// Update postion
		//info(this.position + " || " + speed + " || " + direction)
		new UpdatePosition(this.ID, this.position)
	}

		
	
	
	on Die
	{
		new CarDead().emit[it.UUID == environment]
		info("Agent car : " + this.ID + " stopped by the environment")
		killMe
	}

	def follow(carToFollow : CarBody) : Vector2d {

		if ((carToFollow !== null) && (carToFollow.owner != this.ID)) {
			
			//TODO Code for the car to follow another one
			
		}

	}
	def acceleration  {
		//acceleration linéaire en fonction de la direction du véhicule 
		
			if (direction == 0 && this.speed.y <= group.maxSpeed-acceleration) {
				this.speed.setY(this.speed.getY + acceleration)
				this.speed.setX(0)
			}
			else if (direction == 1 && this.speed.x >= (-group.maxSpeed)+acceleration) {
				this.speed.setX(this.speed.getX - acceleration)
				this.speed.setY(0)
			} 
			else if (direction == 2 && this.speed.x <= group.maxSpeed-acceleration) {
				this.speed.setX(this.speed.getX + acceleration)
				this.speed.setY(0)
			} 
			else if (direction == 3 && this.speed.y >= (-group.maxSpeed)+acceleration) {
				this.speed.setY(this.speed.getY - acceleration)
				this.speed.setX(0)
			}
			else{
			}
			//info("*********************on acc car*********************")
		
	}

	def decceleration {
		// decceleration linéaire en fonction de la direction du véhicule
		
		if (direction == 0 && this.speed.y >= acceleration) {
			this.speed.setY(this.speed.getY - acceleration)
		} else if (direction == 1 && this.speed.x <= -acceleration) {
			this.speed.setX(this.speed.getX +acceleration)
		} else if (direction == 2 && this.speed.x >= acceleration) {
			this.speed.setX(this.speed.getX - acceleration)
		} else if (direction == 3 && this.speed.y <= (-acceleration)) {
			this.speed.setY(this.speed.getY + acceleration)
		} else {
		}
		
		//info("*********************on decc car*********************")
	}
	/*
	 * dir 
	 * [1] right
	 * [2] left
	 * [3] straight
	 * return list of position for curved deplacement in intersection
	 */
	def traverserInter(dir : int) {
		var point = new Vector2d
		var cible= new Vector2d
		var courbe = new Path2d
		courbe.moveTo(this.position.getX(), this.position.getY())
		if (dir == 1){
			if (this.direction == 0) {
				point.setX(this.position.getX())
				point.setY(this.position.getY() + 50)
				cible.setX(this.position.getX()+50)
				cible.setY(this.position.getY() + 50)
				//var q = new QuadPathElement2d(this.position.getX, this.position.getY, point.getX(),
				//	point.getY(), cible.getX(), cible.getY())
				//var a =new ArrayList()
				//a.add(q)
				//var i =a.iterator()
				//courbe = new Path2d(i)
				courbe.quadTo(point.getX(),
						point.getY(), cible.getX(), cible.getY())
				
			}
			if (this.direction == 1) {
				point.setX(this.position.getX()+50)
				point.setY(this.position.getY() )
				cible.setX(this.position.getX()+50)
				cible.setY(this.position.getY() - 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())
				
				}
			if (this.direction == 2) {
				point.setX(this.position.getX()-50)
				point.setY(this.position.getY() )
				cible.setX(this.position.getX()-50)
				cible.setY(this.position.getY() + 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())
				}
			if (this.direction == 3) {
				point.setX(this.position.getX())
				point.setY(this.position.getY() - 50)
				cible.setX(this.position.getX()-50)
				cible.setY(this.position.getY() - 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())
				}
			
		} else if (dir == 2) {
			if (this.direction == 0) {
				point.setX(this.position.getX())
				point.setY(this.position.getY() + 50)
				cible.setX(this.position.getX() - 50)
				cible.setY(this.position.getY() + 50)
				// var q = new QuadPathElement2d(this.position.getX, this.position.getY, point.getX(),
				//	point.getY(), cible.getX(), cible.getY())
				// var a =new ArrayList()
				// a.add(q)
				// var i =a.iterator()
				// courbe = new Path2d(i)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())

			}
			if (this.direction == 1) {
				point.setX(this.position.getX() + 50)
				point.setY(this.position.getY())
				cible.setX(this.position.getX() + 50)
				cible.setY(this.position.getY() + 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())

			}
			if (this.direction == 2) {
				point.setX(this.position.getX() - 50)
				point.setY(this.position.getY())
				cible.setX(this.position.getX() + 50)
				cible.setY(this.position.getY() - 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())
			}
			if (this.direction == 3) {
				point.setX(this.position.getX())
				point.setY(this.position.getY() - 50)
				cible.setX(this.position.getX() - 50)
				cible.setY(this.position.getY() - 50)
				courbe.quadTo(point.getX(), point.getY(), cible.getX(), cible.getY())
				}
			
		} else if(dir == 3){
			//TODO GOTTA GO STRAIT (and fast)
			
		} else if(dir == 0){
			//TODO
		}
		
		return courbe.toPointArray()
		
	}
	
	

	def think(frontCar : CarBody) : Vector2d {

		var distance = 101.0
		
		if(canGo && !nextTo){
			var center = new Vector2d(500,500)
			
			switch(direction){
				case 0: nextTo = this.position.y >= center.y - 110
				case 1: nextTo = this.position.x <= center.x + 110
				case 2: nextTo = this.position.x >= center.x - 110
				case 3: nextTo = this.position.y <= center.y + 110
			}
			
			if (nextTo) {
				cheminIntersection = traverserInter(this.destination)
			}
		}
			
		if (nextTo) {
			if (progressionIntersection < cheminIntersection.length) {
				var point = cheminIntersection.get(progressionIntersection)
				speed.setX(point.x - this.position.x)
				speed.setY(point.y - this.position.y)
				progressionIntersection++
			} else {
			
		
			}
		} else if (frontCar !== null) {
				// info(body.direction)
			if (frontCar.direction == this.direction) {
				// info("*********************on think car in front*********************")
				switch (this.direction) {
					case 0: {
						// if on same line and too close
						if (frontCar.position.getX as int == this.position.getX as int &&
							((frontCar.position.getY - this.position.getY) as int) <= 75 && // body.position.getY - this.position.getY < distance &&
						((frontCar.position.getY - this.position.getY) as int) != 0) {
						// info("***********" + (body.position.getY - this.position.getY) + "*****")
							distance = frontCar.position.getY - this.position.getY
						}
						if (this.position.y >= (400.0 - 20.0)) {
							distance = 75.0
						}
					}
					case 1: {
						if (frontCar.position.getY as int == this.position.getY as int &&
							((frontCar.position.getX - this.position.getX) as int) >= -75 &&
						// body.position.getX - this.position.getX * -1 < distance &&
						((frontCar.position.getX - this.position.getX) as int) != 0) {
							distance = (frontCar.position.getX - this.position.getX) * -1
						}
						if (this.position.x <= (600.0 + 20.0)) {
							distance = 75.0
						}
					}
					case 2: {
						if (frontCar.position.getY as int == this.position.getY as int &&
							((frontCar.position.getX - this.position.getX) as int) <= 75 &&
						// body.position.getX - this.position.getX < distance &&
						((frontCar.position.getX - this.position.getX) as int ) != 0) {

							distance = (frontCar.position.getX - this.position.getX)

						}
						if (this.position.x >= (400.0 - 20.0)) {
							distance = 75.0
						}
					}
					case 3: {
					//info( "*********************" +this.position.getX +" " + body.position.getX+" ********")
						if (frontCar.position.getX as int == this.position.getX as int &&
							((frontCar.position.getY - this.position.getY) as int) >= -75 &&
							((frontCar.position.getY - this.position.getY) as int) != 0) {
							// info("***********" + distance + "*****")
							distance = ( frontCar.position.getY - this.position.getY) * -1
								// info("***********" + distance + "*****")
						}
						if (this.position.y <= (600.0 + 20.0)) {
							distance = 75.0
						}
					}
				}
			}
		}

		switch (this.direction) {
			case 0: {
				if (this.position.y >= (400.0 - 20.0)) {
					if (distance > 20.0)
						distance = 20.0
				}
				}
			case 1: {
				if (this.position.x <= (600.0 + 20.0)) {
					if (distance > 20.0)
						distance = 20.0
				}
			}
				case 2: {
				if (this.position.x >= (400.0 - 20.0)) {
					if (distance > 20.0)
						distance = 20.0
				}
			}
			case 3: {
				if (this.position.y <= (600.0 + 20.0)) {
					if (distance > 20.0)
						distance = 20.0
					}
			}
		}
		

		if ((distance as int) < 100 && (distance as int ) > 0) {
			decceleration()

		} else {
			// info("*********************on call acc car*********************")
			acceleration()

		}
		
		return this.speed

	}
	

}
